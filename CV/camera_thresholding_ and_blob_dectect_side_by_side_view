"""
Live blob detection with OpenCV for ASL Glove CV work.
Captures frames, thresholds bright IR markers, and highlights blobs in real time.
Logs FPS, frame count, and blob coordinates to a timestamped CSV file.
"""

# Suppress linter false positives about cv2 dynamic attributes
# pylint: disable=E1101

import time
import csv
from datetime import datetime
import numpy as np
import cv2


def main() -> None:
    """Main loop to capture frames, detect blobs, and log data."""

    print("OpenCV version:", cv2.__version__)

    # --- Camera setup ---
    cap = cv2.VideoCapture(0)  # Open default camera (index 0)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)   # Request 1280px wide frames
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)   # Request 720px tall frames
    cap.set(cv2.CAP_PROP_FPS, 60)             # Request 60 frames per second

    if not cap.isOpened():
        print("‚ùå Error: Could not open camera.")
        return

    # --- Parameters for blob filtering ---
    THRESH = 200          # Brightness threshold (0‚Äì255)
    MIN_AREA = 40         # Minimum blob area in pixels^2
    MAX_AREA = 2000       # Maximum blob area in pixels^2
    MIN_CIRCULARITY = 0.8 # Require blobs to be round (0‚Äì1)

    kernel = np.ones((3, 3), np.uint8)  # Morphology kernel for cleanup

    # --- FPS + frame counters ---
    prev_time = time.time()
    fps = 0.0
    frame_count = 0

    # --- Timestamped CSV Logger ---
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    log_filename = f"detections_log_{timestamp}.csv"
    log_file = open(log_filename, mode="w", newline="", encoding="utf-8")
    csv_writer = csv.writer(log_file)
    csv_writer.writerow(["Frame", "Timestamp", "FPS", "BlobCount", "BlobCenters"])
    print(f"üìÅ Logging to {log_filename}")

    while True:
        # --- Capture frame ---
        ret, frame = cap.read()
        if not ret:
            print("‚ùå Error: Failed to grab frame.")
            break

        frame_count += 1

        # --- Preprocessing ---
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)   # Grayscale, IR LEDs don't need color info, just brightness
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)      # Gaussian blur with 5x5 kernel to reduce noise

        # --- Thresholding ---
        _, mask = cv2.threshold(blurred, THRESH, 255, cv2.THRESH_BINARY)  # Binary threshold to isolate bright spots, any pixel brighter than THRESH (200) becomes white (255), others black (0)

        # --- Clean mask ---
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1) # Morphological open to remove small specks (noise), kernel = 3x3 matrix of ones, iterations = 1 applies the operation once

        # --- Find blobs ---
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # Find contours (blobs) in the binary mask, only retrieves outmost contours, compresses contour points to save memeory, contour is a list of all candidate LED blobsl for further filtering
        blob_centers = []                          # List to hold blob center coordinates
        for c in contours:                         # Loops over to analyze each contour (a curve joining all the boundary points of a white blob in the thresholded image)
            area = cv2.contourArea(c)              # Calculate area of each contour
            if area < MIN_AREA or area > MAX_AREA: # skips blobs if they are too small (noise) or too large (not an LED)
                continue

            per = cv2.arcLength(c, True)           # Calculates the perimeter of contour (how round the blob is)
            if per <= 0:                           # Safety check to avoid division by zero
                continue

            circularity = 4 * np.pi * area / (per * per + 1e-9) # Calculates the circularity of the blob (perfect circle about= 1, very irregular shape < 0.5)
            if circularity < MIN_CIRCULARITY:                   # discards blobs that aren't circular enough (noise, streaks)
                continue

            M = cv2.moments(c)                   # Computes image moments for the contour (moments are particular weighted averages of image pixel intensities (help calculate centroid))      
            if M["m00"] == 0:                    # Safety check to avoid division by zero
                continue
            cx, cy = int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"])     # computes the centroid of the blob     
            blob_centers.append((cx, cy))                                   # cx = x-coordinate of centroid, cy = y-coordinate of centroid, adds the centroid coordinates to the list of blob centers

            # Draw bounding box
            (x, y, w, h) = cv2.boundingRect(c)                             # computes the bounding box around the blob (x,y are the top-left coordinates, w is width, h is height)
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)   # draws a green rectangle around the blob on the live feed
            cv2.putText(frame, f"({cx},{cy})", (x, y - 10),                # prints the coordinates of the centroid above the bounding box
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1, cv2.LINE_AA)

        # --- FPS calculation ---
        curr_time = time.time()
        elapsed = curr_time - prev_time
        if elapsed > 0:
            fps = 1.0 / elapsed
        prev_time = curr_time

        # --- Overlay FPS + frame count ---
        cv2.putText(frame, f"FPS: {fps:.1f}", (10, 25),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2, cv2.LINE_AA)
        cv2.putText(frame, f"Frame: {frame_count}", (10, 55),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 200, 255), 2, cv2.LINE_AA)

        # --- CSV logging ---
        csv_writer.writerow([
            frame_count,
            f"{curr_time:.4f}",
            f"{fps:.2f}",
            len(blob_centers),
            blob_centers
        ])

        # --- Show side-by-side view ---
        mask_bgr = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
        combined = np.hstack((frame, mask_bgr))
        cv2.imshow("Detections | Threshold Mask", combined)

        # --- Keyboard controls ---
        k = cv2.waitKey(1) & 0xFF
        if k == ord("q"):
            break
        elif k in (ord("+"), ord("=")):
            THRESH = min(255, THRESH + 2)
            print("Threshold:", THRESH)
        elif k in (ord("-"), ord("_")):
            THRESH = max(0, THRESH - 2)
            print("Threshold:", THRESH)

    # --- Cleanup ---
    cap.release()
    log_file.close()
    cv2.destroyAllWindows()


if __name__ == "__main__":
    main()